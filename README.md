# Chessy

### Постановка задачи
Расставить n шахматных фигур (возможно, различных и разного цвета) на доску, размером m*m так, чтобы они

а) Не били друг друга. Если фигуры разного цвета, то белые бьют только чёрных и наоборот. Назовём это задачей о независимости.

б) Покрывали всё поле, то есть чтобы каждая клетка поля была атакована хотя бы одной фигурой. Считается, что клетка, на которой стоит какая-нибудь фигура, покрыта.
Также нет разделения на цвета. Назовём это задачей о доминировании.

Нужно вывести все возможные фундаментальные решения, то есть решения, не получающиеся из других поворотом, отражением и сменой цвета.

### Подход к решению
Разобьём задачу на три части.
* Задача о независимости с фигурами одного цвета
* Задача о независимости с фигурами разных цветов
* Задача о доминировании

Так как нужно перечислить все решения, то воспользуемся методом ветвей и границ или его вариацией. В частности, методом поиска с возвратом (backtracking).
На Википедии можно найти [Задачу о восьми ферзях](https://ru.wikipedia.org/wiki/Задача_о_восьми_ферзях). Это задача о независимости с фигурами одного цвета.
Но эту идею можно использовать во всех трёх случаях. Таким образом, нам нужен алгоритм поиска с возвратом, который мы будем "настраивать"
под конкретную задачу.

Так как одинаковые фигуры неотличимы, то их перестановка будет давать одно и то же решение. Поэтому мысленно пронумеруем поле слева направо,
сверху вниз. То есть если это обычная шахматная доска, то в первой строке будут числа от 0 до 7, во второй от 8 до 15 и т.д.
Тогда следующую одинаковую фигуру будем ставить в клетку с большим номером. Тогда мы не будем получать одинаковые решения.

Основная суть алгоритма:
* Берём новую фигуру
* Если эта та же самая фигура, что и на прошлом шаге, то будем ставить только в номера, большие предыдущего
* Пробуем её поставить на поле с учётом определённых условий
* Если получилось, то рекурсивно вызываем эту же функцию со следующей фигурой. Затем убираем поставленную фигуру
* В начале функции проверяем, если эта последняя фигура, то сохраняем это решение

Это реализовано в solver.recursive_solve(). "Настройка" алгоритма производится наследниками класса board. В нём определены
несколько основных функций: check_chessman() - проверка, можно ли поставить фигуру в данное место поля. set_chessman() - поставить
фигуру в данное место поля, unset_chessman() - снять фигуру, get_solution() - получить решение. Также в классе хранится
двумерный массив фигур - игровое поле.

#### Задача о независимости с фигурами одного цвета
За эту задачу отвечает класс colorless_independent_board.

Для ускорения операций заведём несколько массивов. Два массива длиной m, в которых будем хранить флаги, находится ли под атакой
i-я строка и ряд. А также два массива длиной 2*m-1, в которых будут флаги относительно диагоналей 45 градусов (далее - восходящяя) и
135 градусов (далее - нисходящая).

Проверка проходит так:
* Проверяем, занята ли текущая ячейка (это делается первым шагом во всех остальных наследниках board, поэтому дальше об этом не говорится).
Также проверяем не бьётся ли текущий ряд и строка, а также диагонали. Если что-нибудь выполнятся, то поставить сюда нельзя
* Если фигура ферзь или ладья, то последовательно проверяем все ячейки на текущей строке и ряду. Если есть хоть одна фигура, то
поставить нельзя
* Аналогично если ферзь или слон, только проверяются диагонали
* Далее проверяется, есть ли в заданном наборе фигур короли. Если есть, то проверяем все клетки вокруг текущей. Если там есть король,
либо текущая фигура король и встречается любая другая, то поставить нельзя.
* Аналогично с конём, только провяются клетки, в которые может пойти конь с текущей позиции.
* Проверяется, есть ли в заданном наборе фигур пешки. Считается, что все пешки - белые. То есть бьют они "вниз". Поэтому проверяем,
если текущая фигура пешка, то не бьёт ли она фигуры, которые могут быть внизу. А также проверяем, не могут ли текущую клетку бить
пешки сверху. Если что-то выполняется, то поставить фигуру нельзя
* Если ничего из этого не выполнилось, то фигуру можно поставить

Постановка (снятие) фигуры куда проще. В игровое поле для текущих координат ставим фигуру (зануляем ячейку). Если фигура ферзь или ладья,
то устанавливаем (снимаем) соответствующие "прямые" флаги, если ферзь или слон, то устанавливаем (снимаем) соответствующие диагональные флаги.

Насчёт получение решения. Само решение - это класс solution. Это обёртка над хэш-функцией, которая по паре координат отображает в фигуру (пока примем, что это
просто беззнаковое число, размером один байт). Проходимся по игровому полю, добавляем непустые ячейки в solution.

#### Задача о независимости с фигурами разного цвета
За эту задачу отвечает класс independent_board.

Здесь уже не получится завести такие массивы, так как, например, перед белой ладьёй может стоять белая пешка, тогда все
последующие клетки открыты для чёрных фигур. По похожим причинам будем расставлять сначала все белые фигуры, а только потом чёрные.
Иначе, например, если мы будем ставить сначала белую ладью, а потом чёрного слона, то потеряем случай, когда их будет разделять
белая пешка, потому что слона нельзя будет поставить.

Проверка:
* Если фигура белая, то разрешаем поставить и выходим
*